const path = require("path");
const ocrSpace = require("ocr-space-api-wrapper");

const createImageArea = require("../utils/createImageArea");
const convertMMSSsssToS = require("../utils/convertMMSSsssToS");
const removeDuplicates = require("../utils/removeDuplicates");

const generateQualiResults = async (
  screenshotDir,
  outputDir,
  ocrOpts,
  screenshots
) => {
  // Contains results from the API
  const resArray = [];

  for (const sh of screenshots) {
    const inputPath = path.join(screenshotDir, sh);
    const _driverOutput = path.join(outputDir, `drivers_${sh}`);
    const _timesOutput = path.join(outputDir, `times_${sh}`);

    // Extract driver names into new image
    await createImageArea(inputPath, _driverOutput, 250, 715, 260, 763);

    // Extract lap times into new image
    await createImageArea(inputPath, _timesOutput, 130, 715, 260, 1530);

    const resDrivers = await ocrSpace(_driverOutput, ocrOpts);
    const resTimes = await ocrSpace(_timesOutput, ocrOpts);

    const drivers = resDrivers.ParsedResults[0].ParsedText.split("\t\r\n");
    const lapTimes = resTimes.ParsedResults[0].ParsedText.split("\t\r\n");

    const driverTimes = drivers.reduce((acc, cur, i) => {
      if (cur.length && lapTimes[i]) {
        acc[cur] = lapTimes[i];
      }

      return acc;
    }, {});

    resArray.push(driverTimes);
  }

  // Combine page1 and page2 results.
  // Add seconds for sorting
  const driverObject = { ...resArray[0], ...resArray[1] };
  for (const i in driverObject) {
    driverObject[i] = {
      timeStr: driverObject[i],
      secs: convertMMSSsssToS(driverObject[i]),
    };
  }

  // Get rid of duplicates generated by flaky OCR
  const driverObjectWithoutDuplicates = removeDuplicates(
    driverObject,
    "timeStr"
  );

  // Divide objects into an array so that they can be sorted
  const driverArr = [];
  for (const i in driverObjectWithoutDuplicates) {
    driverArr.push({ name: i, ...driverObjectWithoutDuplicates[i] });
  }

  // Sort by secs
  const finalArr = [...driverArr].sort((a, b) => a.secs - b.secs);

  // Return sorted final results
  return finalArr.map((driver) => ({
    field1: driver.name,
    field2: driver.timeStr,
  }));
};

module.exports = generateQualiResults;
