const path = require("path");
const ocrSpace = require("ocr-space-api-wrapper");

const createImageArea = require("../utils/createImageArea");
const convertMMSSsssToS = require("../utils/convertMMSSsssToS");
const removeDuplicates = require("../utils/removeDuplicates");
const getCorrectPlayerObject = require("../utils/getCorrectedPlayerObject");

const generateQualiResults = async (
  screenshotDir,
  outputDir,
  ocrOpts,
  screenshots,
  playerListFile,
  isRx
) => {
  // Contains results from the API
  const resArray = [];

  for (const sh of screenshots) {
    const inputPath = path.join(screenshotDir, sh);
    const _driverOutput = path.join(outputDir, `drivers_${sh}`);
    const _timesOutput = path.join(outputDir, `times_${sh}`);

    const driverNameAreaReg = [250, 715, 260, 763];
    const bestLapAreaReg = [130, 715, 260, 1530];
    const driverNameAreaRx = [250, 175, 260, 763];
    const totalTimeAreaRx = [130, 175, 260, 1420];

    const nameArea = isRx ? driverNameAreaRx : driverNameAreaReg;
    const timeArea = isRx ? totalTimeAreaRx : bestLapAreaReg;

    // Extract driver names into new image
    await createImageArea(inputPath, _driverOutput, ...nameArea);

    // Extract lap times into new image
    await createImageArea(inputPath, _timesOutput, ...timeArea);

    const resDrivers = await ocrSpace(_driverOutput, ocrOpts);
    const resTimes = await ocrSpace(_timesOutput, ocrOpts);

    const drivers = resDrivers.ParsedResults[0].ParsedText.split("\t\r\n");
    const lapTimes = resTimes.ParsedResults[0].ParsedText.split("\t\r\n");

    const driverTimes = drivers.reduce((acc, cur, i) => {
      if (cur.length && lapTimes[i]) {
        acc[cur] = lapTimes[i];
      }

      return acc;
    }, {});

    resArray.push(driverTimes);
  }

  // Combine results from different screenshots.
  const driverObject = resArray.reduce((acc, cur) => {
    return { ...acc, ...cur };
  }, {});

  // Add seconds for sorting
  for (const i in driverObject) {
    driverObject[i] = {
      timeStr: driverObject[i],
      secs: convertMMSSsssToS(driverObject[i]),
    };
  }

  // Get rid of duplicates generated by flaky OCR
  const driverObjectWithoutDuplicates = removeDuplicates(
    driverObject,
    "timeStr"
  );

  // Compare keys to fetched (program 5) results and use program 5 result keys.
  const correctedDriverObject = getCorrectPlayerObject(
    driverObjectWithoutDuplicates,
    playerListFile
  );

  // Divide objects into an array so that they can be sorted
  const driverArr = [];
  for (const i in correctedDriverObject) {
    driverArr.push({ name: i, ...correctedDriverObject[i] });
  }

  // Sort by secs
  const finalArr = [...driverArr]
    .sort((a, b) => a.secs - b.secs)
    .map((driver) => [driver.name, driver.timeStr]);

  // Remove DNF's before return
  // This is for Rallycross. If a driver ping timeouts it would consider a host
  // on the 4th position in the screenshot. In regular quali there is no DNF
  // as DNF is shown in total time column instead of best lap

  return finalArr.filter((driver) => driver[1] !== "DNF");
};

module.exports = generateQualiResults;
